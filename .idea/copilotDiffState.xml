<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/api/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    id(&quot;org.jetbrains.kotlin.jvm&quot;)&#10;    id(&quot;org.jetbrains.dokka&quot;)&#10;}&#10;&#10;group = &quot;io.oira&quot;&#10;&#10;java {&#10;    withSourcesJar()&#10;    withJavadocJar()&#10;}&#10;&#10;tasks.jar {&#10;    archiveBaseName.set(&quot;FluxEco-API&quot;) // final jar will be like FluxEco-API-1.0.0.jar&#10;    destinationDirectory.set(file(&quot;$rootDir/dist&quot;))&#10;    duplicatesStrategy = DuplicatesStrategy.EXCLUDE&#10;}&#10;&#10;dependencies {&#10;    compileOnly(&quot;io.papermc.paper:paper-api:1.21.4-R0.1-SNAPSHOT&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id(&quot;org.jetbrains.kotlin.jvm&quot;)&#10;    id(&quot;org.jetbrains.dokka&quot;)&#10;}&#10;&#10;group = &quot;io.oira&quot;&#10;&#10;java {&#10;    withSourcesJar()&#10;    withJavadocJar()&#10;}&#10;&#10;tasks.jar {&#10;    archiveBaseName.set(&quot;FluxEco-API&quot;) // final jar will be like FluxEco-API-1.0.0.jar&#10;    destinationDirectory.set(file(&quot;$rootDir/dist&quot;))&#10;    duplicatesStrategy = DuplicatesStrategy.EXCLUDE&#10;}&#10;&#10;dependencies {&#10;    compileOnly(&quot;io.papermc.paper:paper-api:1.21.4-R0.1-SNAPSHOT&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/io/oira/fluxeco/manager/ConfigManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/io/oira/fluxeco/manager/ConfigManager.kt" />
              <option name="originalContent" value="package io.oira.fluxeco.manager&#10;&#10;import org.bukkit.configuration.file.FileConfiguration&#10;import org.bukkit.configuration.file.YamlConfiguration&#10;import org.bukkit.plugin.java.JavaPlugin&#10;import java.io.File&#10;import java.io.IOException&#10;&#10;class ConfigManager(private val plugin: JavaPlugin, private val fileName: String) {&#10;&#10;    private val file: File = File(plugin.dataFolder, fileName)&#10;    private var config: FileConfiguration&#10;&#10;    init {&#10;        ensureFileExists()&#10;        config = YamlConfiguration.loadConfiguration(file)&#10;        instances.add(this)&#10;    }&#10;&#10;    private fun ensureFileExists() {&#10;        if (!file.exists()) {&#10;            plugin.saveResource(fileName, false)&#10;        }&#10;    }&#10;&#10;    fun getConfig(): FileConfiguration {&#10;        ensureFileExists()&#10;        return config&#10;    }&#10;&#10;    fun saveConfig() {&#10;        try {&#10;            config.save(file)&#10;        } catch (e: IOException) {&#10;            plugin.logger.severe(&quot;Could not save config $fileName: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    fun reloadConfig() {&#10;        ensureFileExists()&#10;        config = YamlConfiguration.loadConfiguration(file)&#10;    }&#10;&#10;    companion object {&#10;        private val instances = mutableListOf&lt;ConfigManager&gt;()&#10;&#10;        fun reloadAll() {&#10;            instances.forEach { it.reloadConfig() }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package io.oira.fluxeco.manager&#10;&#10;import org.bukkit.configuration.file.FileConfiguration&#10;import org.bukkit.configuration.file.YamlConfiguration&#10;import org.bukkit.plugin.java.JavaPlugin&#10;import java.io.File&#10;import java.io.IOException&#10;&#10;class ConfigManager(private val plugin: JavaPlugin, private val fileName: String) {&#10;&#10;    private val file: File = File(plugin.dataFolder, fileName)&#10;    private var config: FileConfiguration&#10;&#10;    init {&#10;        ensureFileExists()&#10;        config = YamlConfiguration.loadConfiguration(file)&#10;        instances.add(this)&#10;    }&#10;&#10;    private fun ensureFileExists() {&#10;        if (!file.exists()) {&#10;            plugin.saveResource(fileName, false)&#10;        }&#10;    }&#10;&#10;    fun getConfig(): FileConfiguration {&#10;        ensureFileExists()&#10;        return config&#10;    }&#10;&#10;    fun saveConfig() {&#10;        try {&#10;            config.save(file)&#10;        } catch (e: IOException) {&#10;            plugin.logger.severe(&quot;Could not save config $fileName: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    fun reloadConfig() {&#10;        ensureFileExists()&#10;        config = YamlConfiguration.loadConfiguration(file)&#10;    }&#10;&#10;    companion object {&#10;        private val instances = mutableListOf&lt;ConfigManager&gt;()&#10;&#10;        fun reloadAll() {&#10;            instances.forEach { it.reloadConfig() }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>